class Factory {
    contains Machine[1..*] hasMachine
    contains Worker[1..*] hasWorker

    contains Source[1] hasSource
    contains Sink[1] hasSink
}

abstract class Connectable {
    Connectable[0..2] Provides opposite Receives
    Connectable[0..2] Receives opposite Provides
}

class Source extends Connectable.
class Sink extends Connectable.

class Machine extends Connectable {
    Worker[1..*] worker
    % Shift[0..3] shifts
}

class Worker {
    % Every worker works at least one shift and at most 2
    Shift[1..2] worksShift 
}

class Shift {
}

% There exists a 'morning', 'afternoon' and 'night' Shift
Shift(morning).
Shift(afternoon).
Shift(night).

% There exist no extra shifts
!Shift(Shift::new).

% At least one connects input
error pred hasAInput(Machine m) <-> 
    !Receives(m, _).

% At least one connects output
error pred hasAOutput(Machine m) <-> 
    !Provides(m, _).

% Sink has at least one input
error pred hasAInputSink(Sink t) <->
    !Receives(t, _).

% Source has at least one output
error pred hasAOutputSource(Source s) <->
    !Provides(s, _).

% Source has no input
error hasAInputSource(Source s) <->
    Receives(s, _).

% Sink has no output
error hasAOutputSink(Sink t) <->
    Provides(t, _).

% Every machine that has a worker needs a worker for every shift
pred hasAWorker(Machine m) <->
    worker(m, _).

% pred hasShift(Worker w, Shift s) <->
%     worksShift(w, s).

atom morning.
atom afternoon.
atom night.

% pred worksAtNight(Worker w) <-> 
%     hasShift(w, night).

% pred worksInTheMorning(Worker w) <->
%     hasShift(w, morning).

% pred worksInTheAfternoon(Worker w) <->
%     hasShift(w, afternoon).

% pred worksAllShift(Worker w1, Worker w2, Worker w3) <->
%     worksAtNight(w1), worksInTheAfternoon(w2), worksInTheMorning(w3).

% error allShiftsOccupied(Machine m, Worker w1, Worker w2, Worker w3) <->
%     hasAWorker(m), !worksAllShift(w1, w2, w3).

% Every worker has at least one shift 
    
% Factory Source and Sink have no direct connection
error pred disconnectSourceSink(s, t) <-> Source(s), Sink(t), Provides(s, t).

% Bounded exploration: find a model of at most 20 nodes,
% and containing exactly one factory.
scope node = 0..20, Factory=1, Machine=1, Worker=3.
